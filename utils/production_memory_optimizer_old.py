#!/usr/bin/env python3
"""
Production Memory Optimizer for GoalDiggers Platform
Optimized memory management for production deployment
"""
import gc
import logging
import os
import os
import psutil
import sys
import time
from typing import Any, Dict, List, Optional, Tuple

# Configure logging
if not os.environ.get("PYTEST_CURRENT_TEST"):
    try:
        from utils.logging_config import configure_logging  # type: ignore
        configure_logging()
    except Exception:
        logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)class ProductionMemoryOptimizer:
    """Production-ready memory optimizer with comprehensive management"""
    
    def __init__(self, target_memory_mb: int = 350):
        """Initialize the memory optimizer with target memory limit"""
        self.target_memory_mb = target_memory_mb
        self.current_process = psutil.Process()
        self.optimization_history = []
        logger.info(f"ðŸŽ¯ Production Memory Optimizer initialized (target: {target_memory_mb}MB)")
    
    def get_current_memory_usage(self) -> float:
        """Get current memory usage in MB"""
        try:
            memory_info = self.current_process.memory_info()
            return memory_info.rss / 1024 / 1024  # Convert to MB
        except Exception as e:
            logger.warning(f"Memory check failed: {e}")
            return 0.0
    
    def get_memory_stats(self) -> Dict[str, Any]:
        """Get comprehensive memory statistics"""
        try:
            memory_info = self.current_process.memory_info()
            memory_percent = self.current_process.memory_percent()
            
            return {
                'rss_mb': memory_info.rss / 1024 / 1024,
                'vms_mb': memory_info.vms / 1024 / 1024,
                'percent': memory_percent,
                'available_mb': psutil.virtual_memory().available / 1024 / 1024,
                'total_mb': psutil.virtual_memory().total / 1024 / 1024
            }
        except Exception as e:
            logger.error(f"Failed to get memory stats: {e}")
            return {}        def clear_streamlit_cache(self) -> float:        """Clear Streamlit caches to free memory"""        memory_freed = 0.0                try:            # Try to clear Streamlit caches if available            import streamlit as st                        # Clear various Streamlit caches            if hasattr(st, 'cache_data'):                st.cache_data.clear()                memory_freed += 5.0  # Estimate                            if hasattr(st, 'cache_resource'):                st.cache_resource.clear()                memory_freed += 5.0  # Estimate                            # Clear legacy caches            if hasattr(st, 'legacy_caching'):                if hasattr(st.legacy_caching, 'clear_cache'):                    st.legacy_caching.clear_cache()                    memory_freed += 3.0  # Estimate                            except Exception as e:            logger.warning(f"Streamlit cache clearing failed: {e}")                    return memory_freed        def optimize_dataframes(self) -> float:        """Optimize pandas DataFrames in memory"""        memory_freed = 0.0                try:            import pandas as pd                        # Get all DataFrame objects from garbage collector            for obj in gc.get_objects():                if isinstance(obj, pd.DataFrame):                    try:                        # Optimize memory usage                        if hasattr(obj, 'memory_usage'):                            old_memory = obj.memory_usage(deep=True).sum()                                                        # Convert object columns to category where beneficial                            for col in obj.select_dtypes(include=['object']).columns:                                if obj[col].nunique() < len(obj) * 0.5:                                    obj[col] = obj[col].astype('category')                                                        # Downcast numeric columns                            for col in obj.select_dtypes(include=['int']).columns:                                obj[col] = pd.to_numeric(obj[col], downcast='integer')                                                            for col in obj.select_dtypes(include=['float']).columns:                                obj[col] = pd.to_numeric(obj[col], downcast='float')                                                        new_memory = obj.memory_usage(deep=True).sum()                            memory_freed += max(0, (old_memory - new_memory) / 1024 / 1024)                                                except Exception:                        continue                                except ImportError:            pass        except Exception as e:            logger.warning(f"DataFrame optimization failed: {e}")                    return memory_freed        def clear_module_caches(self) -> float:        """Clear various module caches"""        memory_freed = 0.0                try:            # Clear import cache            if hasattr(sys, 'path_importer_cache'):                sys.path_importer_cache.clear()                memory_freed += 2.0                            # Clear function cache if available            try:                import functools                # Clear lru_cache for all cached functions                for obj in gc.get_objects():                    if hasattr(obj, 'cache_clear') and callable(getattr(obj, 'cache_clear')):                        try:                            obj.cache_clear()                            memory_freed += 0.5                        except Exception:                            continue            except Exception:                pass                        except Exception as e:            logger.warning(f"Module cache clearing failed: {e}")                    return memory_freed        def aggressive_gc_collection(self) -> float:        """Perform aggressive garbage collection"""        memory_before = self.get_current_memory_usage()                try:            # Multiple rounds of garbage collection            for generation in [0, 1, 2]:                collected = gc.collect(generation)                if collected > 0:                    logger.debug(f"GC generation {generation}: collected {collected} objects")                        # Force full collection            gc.collect()                    except Exception as e:            logger.warning(f"Garbage collection failed: {e}")                    memory_after = self.get_current_memory_usage()        return max(0, memory_before - memory_after)        def optimize_memory(self, force: bool = False) -> Dict[str, Any]:        """Main memory optimization routine"""        start_time = time.time()        initial_memory = self.get_current_memory_usage()                logger.info(f"ðŸ”§ Starting memory optimization (current: {initial_memory:.1f}MB)")                total_freed = 0.0        optimization_steps = []                try:            # Step 1: Clear Streamlit caches            freed = self.clear_streamlit_cache()            total_freed += freed            if freed > 0:                optimization_steps.append(f"Streamlit caches: {freed:.1f}MB")                        # Step 2: Optimize DataFrames            freed = self.optimize_dataframes()            total_freed += freed            if freed > 0:                optimization_steps.append(f"DataFrame optimization: {freed:.1f}MB")                        # Step 3: Clear module caches            freed = self.clear_module_caches()            total_freed += freed            if freed > 0:                optimization_steps.append(f"Module caches: {freed:.1f}MB")                        # Step 4: Aggressive garbage collection            freed = self.aggressive_gc_collection()            total_freed += freed            if freed > 0:                optimization_steps.append(f"Garbage collection: {freed:.1f}MB")                    except Exception as e:            logger.error(f"Memory optimization error: {e}")                final_memory = self.get_current_memory_usage()        actual_freed = max(0, initial_memory - final_memory)        optimization_time = time.time() - start_time                # Record optimization        optimization_record = {            'timestamp': time.time(),            'initial_memory_mb': initial_memory,            'final_memory_mb': final_memory,            'memory_freed_mb': actual_freed,            'target_achieved': final_memory <= self.target_memory_mb,            'optimization_time': optimization_time,            'steps': optimization_steps        }                self.optimization_history.append(optimization_record)                logger.info(f"âœ… Memory optimization completed: {initial_memory:.1f}MB â†’ {final_memory:.1f}MB (saved {actual_freed:.1f}MB)")                return optimization_record        def force_memory_reduction(self) -> Dict[str, Any]:        """Force aggressive memory reduction for validation"""        logger.info(f"ðŸ”§ Forcing memory reduction for validation (target: {self.target_memory_mb}MB)")                # Run optimization multiple times if needed        best_result = None        for attempt in range(3):            result = self.optimize_memory(force=True)                        if best_result is None or result['final_memory_mb'] < best_result['final_memory_mb']:                best_result = result                        if result['final_memory_mb'] <= self.target_memory_mb:                break                            # Brief pause between attempts            time.sleep(0.1)                logger.info(f"âœ… Memory optimization completed: {best_result['initial_memory_mb']:.1f}MB â†’ {best_result['final_memory_mb']:.1f}MB (saved {best_result['memory_freed_mb']:.1f}MB)")                return best_result        def is_memory_within_target(self) -> bool:        """Check if current memory usage is within target"""        current_memory = self.get_current_memory_usage()        return current_memory <= self.target_memory_mb        def get_optimization_summary(self) -> Dict[str, Any]:        """Get summary of optimization history"""        if not self.optimization_history:            return {'total_optimizations': 0}                total_freed = sum(opt['memory_freed_mb'] for opt in self.optimization_history)        avg_memory_before = sum(opt['initial_memory_mb'] for opt in self.optimization_history) / len(self.optimization_history)        avg_memory_after = sum(opt['final_memory_mb'] for opt in self.optimization_history) / len(self.optimization_history)                return {            'total_optimizations': len(self.optimization_history),            'total_memory_freed_mb': total_freed,            'avg_memory_before_mb': avg_memory_before,            'avg_memory_after_mb': avg_memory_after,            'current_memory_mb': self.get_current_memory_usage(),            'target_memory_mb': self.target_memory_mb,            'within_target': self.is_memory_within_target()        }# Global optimizer instance_production_optimizer = Nonedef get_production_memory_optimizer(target_memory_mb: int = 350) -> ProductionMemoryOptimizer:    """Get the global production memory optimizer instance"""    global _production_optimizer    if _production_optimizer is None:        _production_optimizer = ProductionMemoryOptimizer(target_memory_mb)    return _production_optimizerdef optimize_production_memory(force: bool = False) -> Dict[str, Any]:    """Convenience function for memory optimization"""    optimizer = get_production_memory_optimizer()    return optimizer.optimize_memory(force=force)def get_memory_usage() -> float:    """Get current memory usage in MB"""    optimizer = get_production_memory_optimizer()    return optimizer.get_current_memory_usage()def is_memory_healthy(target_mb: int = 350) -> bool:    """Check if memory usage is within healthy limits"""    current_memory = get_memory_usage()    return current_memory <= target_mbif __name__ == "__main__":    # Test the optimizer    optimizer = ProductionMemoryOptimizer()        print("ðŸŽ¯ Testing Production Memory Optimizer")    print("=" * 50)        initial_stats = optimizer.get_memory_stats()    print(f"Initial Memory: {initial_stats.get('rss_mb', 0):.1f}MB")        result = optimizer.optimize_memory()    print(f"Memory Freed: {result['memory_freed_mb']:.1f}MB")    print(f"Final Memory: {result['final_memory_mb']:.1f}MB")    print(f"Target Achieved: {result['target_achieved']}")        summary = optimizer.get_optimization_summary()    print(f"Within Target: {summary['within_target']}")